"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInclude2RegExp = exports.pathMatch = exports.parse2PosixPath = exports.getThemeComponentList = exports.isModExist = exports.readFileStrSync = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
// read file content
function readFileStrSync(path) {
    try {
        const resolvedPath = require.resolve(path);
        return (0, fs_1.readFileSync)(resolvedPath).toString();
    }
    catch (error) {
        return false;
    }
}
exports.readFileStrSync = readFileStrSync;
// check if a module existed
const modExistObj = {};
function isModExist(path) {
    if (modExistObj[path] === undefined) {
        try {
            require.resolve(path);
            modExistObj[path] = true;
        }
        catch (error) {
            modExistObj[path] = false;
        }
    }
    return modExistObj[path];
}
exports.isModExist = isModExist;
// the theme package's component list
const componentsListObj = {};
function getThemeComponentList(theme) {
    if (!theme)
        return [];
    if (!componentsListObj[theme]) {
        try {
            const packageRootDir = (0, path_1.dirname)(require.resolve(`${theme}/package.json`));
            const dirPath = `${packageRootDir}/components`;
            componentsListObj[theme] = (0, fs_1.readdirSync)(dirPath) || [];
        }
        catch (error) {
            componentsListObj[theme] = [];
        }
    }
    return componentsListObj[theme];
}
exports.getThemeComponentList = getThemeComponentList;
const parse2PosixPath = (path) => path_1.sep === path_1.win32.sep ? path.replaceAll(path_1.win32.sep, path_1.posix.sep) : path;
exports.parse2PosixPath = parse2PosixPath;
// filePath match
function pathMatch(path, conf) {
    const [regStr, order = 0] = conf;
    const reg = new RegExp(regStr);
    const posixPath = (0, exports.parse2PosixPath)(path);
    const matches = posixPath.match(reg);
    if (!matches)
        return false;
    return matches[order];
}
exports.pathMatch = pathMatch;
function parseInclude2RegExp(include = [], context) {
    if (include.length === 0)
        return false;
    context = context || process.cwd();
    const regStrList = [];
    const folders = include
        .map((el) => {
        if (el instanceof RegExp) {
            const regStr = el.toString();
            if (regStr.slice(-1) === '/') {
                regStrList.push(`(${regStr.slice(1, -1)})`);
            }
            return false;
        }
        const absolutePath = (0, exports.parse2PosixPath)((0, path_1.resolve)(context, el));
        const idx = absolutePath.indexOf('/node_modules/');
        const len = '/node_modules/'.length;
        const isFolder = (0, path_1.extname)(absolutePath) === '';
        if (idx > -1) {
            const prexPath = absolutePath.slice(0, idx + len);
            const packagePath = absolutePath.slice(idx + len);
            return `(${prexPath}(\\.pnpm/.+/)?${packagePath}${isFolder ? '/' : ''})`;
        }
        return `(${absolutePath}${isFolder ? '/' : ''})`;
    })
        .filter((el) => el !== false);
    if (folders.length) {
        regStrList.push(`(^${folders.join('|')})`);
    }
    if (regStrList.length > 0) {
        return new RegExp(regStrList.join('|'));
    }
    return false;
}
exports.parseInclude2RegExp = parseInclude2RegExp;
